---
title: "Analysis of Serial Measures"
author: "Holger Burchert"
date: "16 5 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This code is an implementation of the article "Analysis of Serial Measures in Medical Research" by Matthews et al. 1990 (BMJ). The szenario is, that two groups of intrest performed an exercise test after which the heart rate of the participants declines. The following code fits a regression line through the heart rate for each participant and stores the slope into a storage. The means of the slopes from the two groups are then compared by an independent samples t-test and the results plotted. The data come from a csv-file were the first colum contains the time points at which heart rate data were measured. The other colums contain the heart rate data which were measured at the corresponding time points. 

```{r} 
data <- read.csv(
    "C:/Users/neo/Documents/Privat/R/Summary Code/summary2.csv",
    header = TRUE,
    sep = ";"
  )
```

First some storages are built which will later be filled with outcomes from the regressions. 
```{r}
# Group A suffix = .A 
 models.A   <- list() # storage for regression models  
 slopes.A   <- c()    # stroage for the slopes 
r.sqrds.A   <- c()    # storage for r squareds

# Group B suffix = .B
 models.B   <- list() # storage for regression models  
 slopes.B   <- c()    # stroage for the slopes 
r.sqrds.B   <- c()    # storage for r squareds
```

Now, a loop will be created. It conducts a regression von HR vs time and repeats this for each participant. During this loop, each regression model is stored in "models.A", while each slope is stored in "slopes.A" and the r-squared is stored in "r.sqrds.A". 
```{r}
# Looping regressions of HR vs time for Group A
for (i in names(data)[-1][1:9]) { # [-1] = omits time, [1:9] = desired columns         
   models.A[[i]] <-         lm(get(i) ~ zeit, data)                 # store model
   slopes.A[[i]] <-    coef(lm(get(i) ~ zeit, data))["zeit"]        # store slope
  r.sqrds.A[[i]] <- summary(lm(get(i) ~ zeit, data))[["r.squared"]] # store r^2
}
```

Since having the r-squareds is not enough (Anscombe's Quartett) all the regressions for each participant are plotted to evaluate whether the linear model is a good fit to the data. This is, again, done by looping the regressions. 
```{r}
par(mfrow = c(2, 3)) # merges the graphs to be looped in one graph
for (i in names(data)[-1][1:9]) { # [-1] = omits time, [1:9] = Group A 
  plot(get(i) ~ zeit,
         ylab = "HF (bpm)",
         main = i, 
          col = "steelblue",
          data) 
  abline(models.A[[i]])  # add linear fit from models
}
```

New the regressions are looped for group B
```{r}
# Looping regressions of HR vs time for Group B
for (i in names(data)[-1][10:15]) { # [-1] = omits time, [10:15] = Group B                   
   models.B[[i]] <-         lm(get(i) ~ zeit, data)                 # store model
   slopes.B[[i]] <-    coef(lm(get(i) ~ zeit, data))["zeit"]        # store slope
  r.sqrds.B[[i]] <- summary(lm(get(i) ~ zeit, data))[["r.squared"]] # store r^2
}
```

Now the regressions are plotted 
```{r}
# Looping regression plots for Group B
par(mfrow = c(2, 3)) # merges the looped graphs in one graph
for (i in names(data)[-1][10:15]) { # try indexing here as in other loops
  plot(get(i) ~ zeit,
         ylab = "HF (bpm)",
         main = i, 
         col  = "red",
         data)# Plotting
  abline(models.B[[i]])  # add linear fit from models
}
```

Creating histograms for the r-squareds to show how frequent certain values occured. 
```{r}
# Histogram r squared's Group A
par(mfrow = c(1,1))
hist(
  r.sqrds.A,
  freq   = TRUE,
  col    = "steelblue",
  xlab   = "r.squared",
  breaks = 25,
  main   = "Histogram Group A"
)

# Histogram r squared's Group B
par(mfrow = c(1,1))
hist(
  r.sqrds.B,
  freq   = TRUE,
  col    = "red",
  xlab   = "r.squared",
  breaks = 25,
  main   = "Histogram Group B"
)
```

## Conduct Statistical Tests

Assessing whether the slopes are Gaussian distributed. 
```{r}
# Assessing normal distribution Group A
par(mfrow = c(1,1)) # resets the "merge graphs" function
qqnorm(slopes.A,
       pch   = 1,
       frame = FALSE,
       main  = "Slopes.A")
qqline(slopes.A,
       col   = "steelblue",
       lwd   = 2)

# Assessing normal distribution Group B
par(mfrow = c(1,1)) # resets the "merge graphs" function
qqnorm(slopes.B,
       pch   = 1,
       frame = FALSE,
       main  = "Slopes.B")
qqline(slopes.B,
       col   = "red",
       lwd   = 2)
```

```{r}
# Assessing if variances are the same
# F test for equal variances 
var.test(slopes.A, slopes.B)
```

```{r}
# Conducting t-test
t.result <- t.test(
  slopes.A,
  slopes.B,
  paired      = FALSE,
  var.equal   = TRUE, # accroding to var.test result
  conf.level  = 0.95,
  alternative = "two.sided"
)

print(t.result)
```

Plotting the results
```{r}
boxplot(slopes.A, 
        slopes.B, 
        col = "steelblue",
        ylim = c(0.0,-0.2),
        main = "Results: Red lines indicate \n 95%CI diff from t-test"
)
abline(h = mean(slopes.B) + t.result$conf.int[1], col = "red") # 95%CI lower lim
abline(h = mean(slopes.B) + t.result$conf.int[2], col = "red") # 95%CI upper lim
```